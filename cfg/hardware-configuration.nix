# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{
	config,
	lib,
	pkgs,
	...
}:

{
	imports =
	[
		<nixpkgs/nixos/modules/installer/scan/not-detected.nix>
		./subroot.nix
	];
	
	boot.initrd.availableKernelModules =
	[
		"ata_generic"
		"uhci_hcd"
		"ehci_pci"
		"ahci"
		"firewire_ohci"
		"usb_storage"
		"sd_mod"
		"sr_mod"
		"sdhci_pci"
		"ahci"
		"uas"
	];
	
	boot.kernelModules =
	[
		"kvm-intel"
	];
	
	boot.kernelParams =
	[
		"boot.shell_on_fail"
		
		# enable kernel debugging (events log level)
		#"debug"
		
		#"loglevel=7"
		
		# do not show the linux logo
		"logo.nologo"
		
		# time before automatic reboot on kernel panic
		# seconds to wait, to reboot, after a kernel panic (0 (default): wait indefinitely):
		#"panic=5"
		
		# mount subdirectory path as rootfs
		"subroot_path=/mach/D2b6sT0ASCnp7KWOZTgTYJkks73R1dLt-nixos-x86_64.d"
		"sleep_s=15"
	];
	
	boot.extraModulePackages =
	[
		config.boot.kernelPackages.exfat-nofuse
	];
	
	#boot.extraModprobeConfig =
	#"
	#	options snd slots=snd-hda-intel
	#";
	
	boot.loader.grub.copyKernels = false;
	# "boot.loader.grub.storePath" valid only if "boot.loader.grub.copyKernels=false"
	#boot.loader.grub.storePath = "/nix/store";
	
	# these are declared in "./subroot.nix"
	subroot.path = "/mach/D2b6sT0ASCnp7KWOZTgTYJkks73R1dLt-nixos-x86_64";
	subboot.path = "/mach/D2b6sT0ASCnp7KWOZTgTYJkks73R1dLt-nixos-x86_64/boot";
	subboot.mnt.enabled = true;
	subboot.mnt.src = "/dev/disk/by-uuid/f3f9b214-f0df-44fe-83c5-87bab913d99b";
	subboot.mnt.dest = "/boot.d";
	subboot.mnt.opt = "defaults";
	#boot.loader.grub.subroot = "";
	#boot.loader.grub.subroot_boot = "";
	
	boot.initrd.postMountCommands =
	''
		#echo "`sleep $sleep_s`";
		#sleep $sleep_s;
		#
		#targetRoot="$targetRoot$subroot";
		#
		#echo "`sleep $sleep_s`";
		#sleep $sleep_s;
		
		#local root_mtpt_orig;
		#local root_mtpt;
		#local subroot_mntpt;
		
		
		# Handle the mounting of subroot and subboot.
		#
		echo -E 'mounting "root:'"$subroot_path"'" on "/"...';
		echo -E 'mounting "'"$root"':'"$subroot_path"'" on "/"...';
		#echo -E 'mounting "'$(readlink --silent --canonicalize-missing --no-newline "/dev/root")':'"$subroot"'" on "/"...';
		#echo -E 'mounting "'$(readlink -f -n "/dev/root")':'"$subroot"'" on "/"...' || fail;
		#echo -E 'mounting "'"$_root_src"':'"$subroot_path"'" on "/"...' || fail;
		
		root_mtpt_orig="$targetRoot";
		root_mtpt='/mnt_root';
		subroot_mtpt='/mnt_subroot';
		#subboot_mntpt='/mnt_subboot';
		boot_mntpt='/mnt_boot';
		
		mkdir -p "$root_mtpt";
		mkdir -p "$subroot_mtpt";
		#mkdir -p "$subboot_mntpt";
		mkdir -p "$boot_mntpt";
		
		
		# keep the original $targetRoot path value intact, for later usage as $subroot_path,
		# changing it could possibly break things, in the future or otherwise
		# 
		echo "# \`mount --move \"$root_mtpt_orig\" \"$root_mtpt\";\`";
		sleep $sleep_s;
		mount --move "$root_mtpt_orig" "$root_mtpt" || fail;
		
		# tmp workaround
		# 
		# useful when $subroot path is empty (not an actual root)
		# 
		#if [ -n "$subroot_path" ]
		#then
			# make populated root available at $subroot_path;
			# 
			echo "# \`mount -o rbind \"$root_mtpt\" \"$root_mtpt$subroot_path\";\`";
			sleep $sleep_s;
			mount -o rbind "$root_mtpt" "$root_mtpt$subroot_path" || fail;
			
			#echo "mount --rbind \"$targetRoot\" \"$targetRoot$subroot_path\"";
			#sleep $sleep_s;
			#mount --rbind "$targetRoot" "$targetRoot$subroot_path";
		#fi
		
		# Handle mounting subboot
		echo "# \`if [ $subboot_mnt_enabled || \"$subboot_mnt_enabled\" != \"0\" ]\`";
		sleep "$sleep_s";
		if [ $subboot_mnt_enabled -o "$subboot_mnt_enabled" != "0" ]
		then
			echo '::true';
			if [ -z "$subboot_mnt_opt" ]
			then
				echo "# \`mount \"$subboot_mnt_src\" \"$boot_mntpt\";\`";
				sleep "$sleep_s";
				mount "$subboot_mnt_src" "$boot_mntpt" || fail;
			else
				echo "mount -o \"$subboot_mnt_opt\" \"$subboot_mnt_src\" \"$boot_mntpt\";\`";
				sleep "$sleep_s";
				mount -o "$subboot_mnt_opt" "$subboot_mnt_src" "$boot_mntpt" || fail;
			fi
			
			echo "# \`mount -o rbind \"$boot_mntpt$subboot_path\" \"$root_mtpt$subroot_path$subboot_mnt_dest\";\`";
			sleep "$sleep_s";
			mount -o rbind "$boot_mntpt$subboot_path" "$root_mtpt$subroot_path$subboot_mnt_dest" || fail;
		else
			echo '::false';
		fi
		sleep "$sleep_s";
		
		# make the $subroot path a mountpoint;
		# "switch_root" expects this, and it does not proceed if this is not true
		# 
		echo "# \`mount -o rbind \"$root_mtpt$subroot_path\" \"$subroot_mtpt\";\`";
		sleep $sleep_s;
		mount -o rbind "$root_mtpt$subroot_path" "$subroot_mtpt" || fail;
		#
		#echo "# mount --rbind \"$targetSubroot\" \"$targetRootOrig\"";
		#sleep $sleep_s;
		#mount --rbind "$targetSubroot" "$targetRootOrig";
		#
		
		# make "$root$subroot" available directly
		# back at the originally mounted root mountpoint path
		# for direct usage, without needing to change the value
		# of $targetRoot, as stated previously;
		# changing it could break other parts of the script,
		# if those parts actually use a hardcoded path, for example
		# 
		echo "# \`mount -o rbind \"$subroot_mtpt\" \"$root_mtpt_orig\";\`";
		sleep $sleep_s;
		mount -o rbind "$subroot_mtpt" "$root_mtpt_orig" || fail;
		
		##targetRoot="$targetRootDev$subroot";
		#targetRoot="$targetRoot$subroot";
	'';
	
	fileSystems."/" =
	{
		device = "/dev/disk/by-uuid/f3f9b214-f0df-44fe-83c5-87bab913d99b";
		fsType = "xfs";
		
		## for ext4:
		#options =
		#[
		#	"acl"
		#	"barrier=1"
		#	"data=journal"
		#	"journal_checksum"
		#	"nodelalloc"
		#	"relatime"
		#	"rw"
		#	"sync"
		#	"user_xattr"
		#];
	};
	
	swapDevices =
	[
		{
			device = "/swap.sys";
			size = 4096;
		}
	];
	
	nix.maxJobs = lib.mkDefault 2;
	powerManagement.enable = true;
	powerManagement.cpuFreqGovernor = lib.mkDefault "powersave";
	#powerManagement =
	#{
	#  enable = true;
	#  cpuFreqGovernor = "powersave";
	#};
}
